# 生字与生字率

**1. 引言**

本文档旨在详细解释中文学习平台项目中的核心概念：**生字**和**生字率**，以确保团队成员在开发过程中对这些概念有清晰、统一的理解。由于生字率直接影响用户学习体验和故事生成质量，因此务必保证其计算的准确性。

**2. 核心定义**

在中文学习平台项目中，我们使用以下核心定义：

*   **字 (Character)**
    *   **定义**: 汉字是中文的基本书写单位，例如 "我"、"你"、"好"、"学"、"习" 等。
    *   **注意**:  **标点符号和非中文字符不属于字，在计算生字率时不应包含标点符号和非中文字符。**
*   **词 (Word)**
    *   **定义**:  词是由一个或多个汉字组成的具有完整语义的语言单位，例如 "你好"、"朋友"、"学习"、"火车站" 等。
    *   **注意**:  **词的词性 (part of speech) 非常重要**，词性 (part of speech) 会影响词的含义，例如 “白色” 和 “白说”， “白” 字的词性 (part of speech) 不同。词性标注有助于理解句子结构。
*   **词性 (Part of Speech)**
    *   **定义**: 词的语法分类， 例如： 名词 (noun), 动词 (verb), 形容词 (adjective), 副词 (adverb) 等。**词性标注** 是指对句子中的每个词语确定其词性的过程。
    *   **意义**: 词性标注在自然语言处理中非常重要，有助于理解句子结构和含义。例如， “白色” 和 “白说” 虽然都有 “白” 字，但是它们的词性 (part of speech) 不同（“白色”是形容词，“白说” 是动词），因此含义也不同。
    *   **常用词性**: 常用的词性包括：
        *   `n`：名词 (noun),  表示人或事物的名称，如 "苹果", "学校", "老师"。
        *   `v`：动词 (verb),  表示动作或者状态，如 "跑", "吃", "是"。
        *   `adj`：形容词 (adjective),  表示事物的性质或者状态，如 "好", "坏", "大"。
        *   `adv`：副词 (adverb),  修饰动词，形容词或者其他副词，如 "很", "非常", "快"。
        *   `PR`：代词 (pronoun)， 代替名词或者名词性的短语, 例如 "你", "我", "他"。
        *  `t`:  时间词 (temporal noun), 表示时间, 例如: "今天"，"早上"。
    *   **注意**: **同一个字， 在不同词性 (part of speech) 下，可以被视为不同的词语**，例如，“白” 在 “白色” 中是形容词， 在 “白说” 中是动词，虽然都是 “白” 字，但是它们的词性 (part of speech) 不同，词性 (part of speech) 可以帮助理解词的含义。**然而，在当前版本的生字率计算中，我们主要关注字 (character) 本身是否在已知词汇中出现， 暂不考虑字的词性 (part of speech)。** 未来版本可能会根据需求考虑字的词性 (part of speech)。
*   **超童级别 (Chaotong Level)**
    *   **定义**: 本项目中使用的自定义词汇等级，用于表示词汇的难度。 例如 1-100 的整数， 数字越小，难度越低。
    *   **注意**: 每个词汇都有一个对应的超童级别，例如，级别 1 的词汇比级别 10 的词汇更简单。
*   **已知字 (Known Character)**
    *   **定义**: 如果一个字 (character) 出现在目标级别**以下级别**的词汇中，则为已知字。
    *   **核心要点**:
        *   **基于字的存在**:  已知字的判断只基于字是否在目标级别**以下级别**的词汇中出现。**在当前版本中，字的词性 (part of speech)（而不是词 word 的词性）不作为已知字判断的依据。**
    *   **反向定义**:
        *   **不是已知字**: 如果一个字不在目标级别**以下级别**的词汇中出现，则它不是已知字。
    *   **正确示例**:
        *   如果目标级别为 10， 并且 `words.json` 文件中存在 "喜欢" (级别:5) 和 "跑步" (级别: 10) 的词汇，那么，对于文本 "我喜欢跑步"， "喜", "欢" 是已知字, "跑", "步" 不是已知字。
         *   如果目标级别为 10， 并且 `words.json` 文件中存在 "白色"  (级别: 10) 和 "白说" (级别:10), 那么对于文本  "白色，白说"，  “白”, "色", "说" 都不是已知字。
    *  **注意**: **在当前版本中，已知字的判断不考虑字的词性 (part of speech)。 只有字在目标级别以下级别的词汇中出现，才认为是已知字。**
*   **生字 (New Character)**
    *   **定义**: 在指定目标级别**及其以下级别**中，所有词汇不包含的字，被认为是生字。
    *   **反向定义**:
        *   **不是生字**: 如果一个字出现在目标级别**及其以下级别**的词汇中，则它不是生字。
     *  **如果一个字不在 `words.json` 中，则一定是生字。**
    *   **正确示例**:
        *   如果目标级别为 10， 并且 `words.json` 文件中不存在 "游泳" 的词汇，那么对于文本 "我喜欢游泳"， "游"，"泳" 都是生字。
        *  如果目标级别为 10， 并且 `words.json` 文件中只存在 “白色” (级别：10)， 那么对于文本  "白色，白说"， “说” 字是生字。因为 "白说" 这个词汇并不在 `words.json` 中。
    *   **注意**:  **在当前版本中，生字的判断不考虑字的词性 (part of speech)。**  只要一个字没有在目标级别**及其以下级别**的词汇中出现，就认为是生字。
*   **生字率 (New Character Rate)**
    *   **定义**: 指文本中生字的数量与文本中所有字的数量的比率。
    *   **关键点**:
        *   **生字数量**: 文本中生字的个数。**同一个字在不同词性 (part of speech) 下，视为同一个字 (在当前版本中，不考虑字的词性 (part of speech))**。
        *   **总字数**: 文本中所有汉字的个数， **不包含标点符号和非中文字符**。
    *   **计算公式**:
        *   `生字率 = 生字数量 / 总字数`
        *    `已知字率 = 已知字数 / 总字数`
        *   `生字率 = 1 - 已知字率`
    *   **注意**:
        *   生字率是一个相对的概念，它取决于目标级别。

**3. 生字率计算步骤**

   生字率的计算步骤如下：

1.  **文本预处理**
    *   **提取中文**: 使用正则表达式提取文本中的所有中文字符。**排除标点符号和非中文字符**。
2.  **已知词汇加载**
    *   加载 `words.json` 文件中的所有词汇，并根据目标级别过滤出已知词汇，使用 `_load_known_words` 函数, 并存储已知字。
        *   **`_load_known_words` 函数**: 加载**小于目标级别**的所有词汇，构建一个集合 (set), 包含所有已知字。
3.  **生字判断**
    *   遍历文本中的每一个汉字。
    *   如果该字存在于已知字集合中，则该字是已知字。
    *   如果该字不存在已知字集合中，则是生字。 **如果一个字不在 `words.json` 中，则一定是生字。**
4.  **生字计数**: 统计文本中所有字的数量，以及已知字的个数。 **同一个字在不同词性 (part of speech) 下，视为同一个字 (在当前版本中，不考虑字的词性 (part of speech))**。
5.  **生字率计算**: 使用以下公式计算生字率：
    *   `生字率 = 生字数量 / 总字数`
    *    `已知字率 = 已知字数 / 总字数`
    *   `生字率 = 1 - 已知字率`

**4. 重点总结 (Lessons Learned)**

*   **精确理解定义**: 务必清晰理解生字、已知字和生字率的定义，避免产生歧义。**当前版本的生字率计算只关注字是否在已知词汇中出现， 不考虑字的词性 (part of speech)。**
*   **已知字的定义：**  **已知字是指目标级别 *以下级别* 中出现的字，不包括目标级别的字。**
*    **`words.json` 的重要性**: **生字的判断依赖于 `words.json` 文件，如果一个字不在 `words.json` 中，则一定是生字。**
*   **简化实现**:  在当前阶段，生字率的计算只需要关注字本身，不需要引入复杂的分词和词性 (part of speech) 标注。
*   **避免过度设计**:  在没有明确需求的情况下，不要过早地引入复杂的逻辑。
*   **测试驱动开发**: 编写测试用例能够帮助我们尽早发现代码中的错误和理解上的偏差。
*   **及时沟通**: 及时沟通和反馈可以帮助我们纠正理解上的偏差，确保对问题的看法一致。
*   **代码实现必须严格遵循定义**:  代码实现必须与文档中的定义保持一致。

**5. 未来方向**
   *   未来，如果需要考虑字的词性 (part of speech)， 我们需要修改 `_load_known_words`， `_is_known_char` 和 `calculate_literacy_rate`  函数，并且修改测试用例。

**6. 最佳实践**

*   **理解定义**: 务必理解生字、已知字和生字率的定义，避免产生歧义。
*    **`words.json` 的重要性**: **生字的判断依赖于 `words.json` 文件，如果一个字不在 `words.json` 中，则一定是生字。**
*   **避免硬编码**:  不要在代码中硬编码任何级别值，应该从配置中读取。
*   **添加日志**: 在关键步骤添加日志，方便调试。
*   **异常处理**: 当 `words.json` 文件无法加载时，应该抛出异常并进行处理。
*   **边界情况**: 当 `words.json` 为空时，所有的汉字都应该被认为是生字。

**7. 总结**

本文档详细阐述了中文学习平台项目中的生字和生字率的概念。通过正确理解这些概念，并严格按照文档中的定义和计算步骤实现代码，我们可以确保生字率计算的准确性，从而为用户提供更好的学习体验.  **务必注意，生字率的计算依赖于 `words.json` 文件，如果一个字不在 `words.json` 中，则一定是生字。**



**核心要点：**

1. **精确理解需求和定义至关重要：**
    *   **生字的定义：** 我们一开始在“生字”的理解上存在偏差。文档中明确指出，生字是基于目标级别及其以下级别中**所有词汇不包含的字**。 这意味着我们只需要关注字本身是否在已知词汇中出现，而不需要过度关注文本中的词语构成和词性（至少在当前阶段的生字率计算是这样）。
    *   **区分字和词：** 需要明确区分“字”（单个汉字）和“词”（具有完整语义的语言单位）。 生字率是基于字的计算，而词汇管理和使用可能涉及更复杂的词性分析。
    *   **明确生字率的计算方式：** 生字率 = 生字数量 / 总字数。  总字数只包含汉字，不包含标点符号和非中文字符。

2. **代码实现必须严格遵循定义：**
    *   **`_load_known_words` 的职责：** 这个函数的核心任务是根据目标级别，准确加载所有已知的**字**。  最初的版本中，我对它的理解可能存在偏差，导致加载的已知字集合不准确。
    *   **简化计算逻辑：**  最初我引入了自定义分词并试图考虑词性，这在当前阶段是过度设计了。  简化计算逻辑，直接判断每个字是否在已知字集合中，更符合当前的需求和定义。
    *   **测试驱动开发（TDD）的价值：**  编写测试用例能够帮助我们尽早发现代码中的错误和理解上的偏差。 失败的测试用例是宝贵的反馈，指引我们去重新审视需求和代码实现。

3. **持续沟通和澄清：**
    *   你能够及时指出我在字数计算上的错误，这非常重要。 沟通能够帮助我们纠正理解上的偏差，确保我们对问题的看法是一致的。
    *   当你对需求或定义有疑问时，及时提出来讨论，避免在不清晰的情况下进行开发。

4. **迭代和重构：**
    *   软件开发是一个迭代的过程。  最初的代码可能不完美，但通过不断的测试、分析和重构，我们可以逐步改进代码质量，使其更符合需求。
    *   勇于放弃不必要的复杂性，追求简洁有效的实现方式。

5. **仔细阅读和理解文档：**
    *   `生字与生字率.md` 文档是定义核心概念的重要依据。  在开发过程中，需要反复参考文档，确保代码实现与文档描述一致。  我最初对文档的理解可能不够深入，导致了实现上的偏差。

**我的个人反思：**

*   **避免过度设计：**  在没有明确需求的情况下，不要过早地引入复杂的逻辑（比如在生字率计算中考虑复杂的词性分析）。  保持代码的简洁性，专注于解决当前的核心问题。
*   **重视基础概念：**  对于核心概念（如生字、生字率）的定义，务必理解透彻，避免模糊不清。
*   **测试用例的覆盖度：**  确保测试用例能够覆盖各种边界情况和正常情况，以便更全面地验证代码的正确性。

